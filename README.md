# ДЗ по курсу "Конфигурационное управление" в РТУ МИРЭА
## Описание
В данном репозитории находятся домашние задания, выполненные на 3ем семестре РТУ МИРЭА, по дисциплине "Конфигурационное управление".

Хочется выразить большую благодарность Петру Николаевич Советову [@true-grue](https://github.com/true-grue) за лекции, практики и интересные задания!
## Содержание
1. [Эмулятор консоли](#task1)
1. [Визуализатор зависимостей пакета](#task2)
1. [Выдуманный конфигурационный язык](#task3)
1. [Мини-версия Make](#task4)
## Задания

### <a name="task1"></a> 1. Эмулятор консоли (ConsoleEmulator)

Эмулятор командной строки на языке Python с использованием библиотек zipfile (для работы с zip-архивом), sys (получение адреса архива из командой строки), os.path (работа с адресами), calendar (форматирование даты файла для вывода)

Для тестирования необходимо разместить `main.py`, `archive.py` в одном каталоге (для удобства тестируемый архив можно разместить в этом же каталоге, тогда вторым аргументом при запуске main.py передать только имя архива и тип) и запустить `main.py`

Эмулятор поддерживает команды `cd`, `ls`, `ls -l`, `cat`, `pwd`

**Структура программы:**
- `main.py` — содержит функцию `main`, которая создает объект класса `Archive` и в бесконечном цикле передает ему аргументы командной строки, обрабатывая их и вызывая соответствующие методы объекта

- `archive.py` — содержит описание класса `Archive` и несколько вспомогательных функций для работы

**Демонстрация:**

![image](https://user-images.githubusercontent.com/71013663/145852634-bc9e965e-4e05-43c4-87c8-46a869702dc1.png)


### <a name="task2"></a> 2. Визуализатор зависимостей пакета (DependencyGraph)

Визуализатор зависимостей пакетов pypi на языке Python. Возвращает граф в виде кода на языке Graphviz. 

**Программа состоит из функций:**
- `main` — начальная точка выполнения программы
- `getDeps` — получение зависимостей с помощью запроса - скачивание whl-пакета актуальной версии указанной на pypi и чтении METADATA
- `formatDepsToNestedDicts` — форматирование зависимостей и представление их в виде вложенных словарей
- `convertNestedDictsToLinks` — конвертирование вложенных словарей в связи между пакетами, возврат строки связей
В основе `formatDepsToNestedDicts` и `convertNestedDictsToLinks` рекурсивный обход в глубину

Дополнительно использовались библиотеки requests и sys — для отправки запросов и получения аргументов командой строки.

**Демонстрация:**

![image](https://user-images.githubusercontent.com/71013663/145852226-c33aada7-4693-4b38-8dd1-4e52bece4ee5.png)


### <a name="task3"></a> 3. Выдуманный конфигурационный язык (ConfLang)

Синтаксис языка в форме Бэкуса — Наура:
```
program ::= { statements } object
statements ::= statement | statement statements |
statement ::= NAME ASSIGN value;

object ::= ( assign ) | ( assign, list_assign ) | ( )
list_assign ::= assign list_assign |

assign ::= NAME(list_value)
list_value ::= value list_value |
value ::= object | string | number | &NAME | for(b e s) | for(b e s PATTERN)
```

Файл моего конфигурационного языка состоит из двух частей:
- Область объявления переменных;
- Область описания объектов.


**Область объявления** переменных обозначается фигурными скобками и состоит из списка "утверждений".

Каждое **утверждение** отделяется точкой с запятой.
Утверждение состоит из имени переменной, знака "равно" и списка значений, который данной переменной присваивается. Если список значений состоит из одного элемента, то это уже не список, а просто значение.

**Значением** может быть объект, строка, число, разыменованная с помощью `&` переменная, список полученный из одного из циклов `for`. 

**Строка** и **число** это самые простые типы:
- Строка — набор символов, заключенный в двойные кавычки
- Число — число из множества натуральных.

**Объект** заключен в скобки и содержит список соответствий.

**Соответствия** состоят из имени и значения.

Чтобы извлечь значение объявленное в области переменных, нужно разыменовать переменную с помощью амперсанда `&`.

Циклы `for` используются главным образом для генерации массивов.
>
> `for(b e s)` принимает 3 числа:
> - `b` — begin
> - `e` — end
> - `s` — step
> 
> Возвращает массив из чисел

> `for(b e s PATTERN)` принимает также 3 числа и шаблон строковой переменной, внутри которой есть амперсанд `&`, на место этого амперсанда вставляются числа и из данного цикла `for` возвращается массив из строковых переменных.

**Демонстрация**

![image](https://user-images.githubusercontent.com/71013663/145853069-8e28d59d-e675-4218-b2c4-25ac4f23a3f3.png)


### <a name="task4"></a> 4. Мини-версия Make (MiniMake)
Проект разбит на 3 файла:
- `maker.py` (главный файл, содержит вызовы функций из остальных файлов)
- `analyzer.py` (анализатор содержимого makefile с помощью SLY, решена проблема с отступами)
- `top_sort.py` (алгоритм топологической сортировки, получает граф зависимостей в виде словаря, возвращает массив узлов)

Для того, чтобы повторные задачи не выполнялись, используется хранение хэшей в файле `memory.json`.

Также программа может выводить зависимости задач в коде graphviz, данную функцию можно включить ключом `-v`

**Демонстрация работы**

Для демонстрации создал 4 файла: `factorial.cpp`, `hello.cpp`, `main.cpp`, `functions.h`

Написал соответствующий `makefile` с выводом в консоль с помощью `еcho` выполненной задачи:

```
all: hello

hello: main.o factorial.o hello.o
 g++ main.o factorial.o hello.o -o hello
 echo "Компоновка исполняемого файла"
 
main.o: main.cpp
 g++ -c main.cpp
 echo "Компиляция main.cpp"

factorial.o: factorial.cpp
 g++ -c factorial.cpp
 echo "Компиляция factorial.cpp"

hello.o: hello.cpp
 g++ -c hello.cpp
 echo "Компиляция hello.cpp"
```

1. Команда и результат первого вызова.
```
Input:
maker.py -v makefile

Output:
"all" -> "hello";
"hello" -> "main.o";
"hello" -> "factorial.o";
"hello" -> "hello.o";
"main.o" -> "main.cpp";
"factorial.o" -> "factorial.cpp";
"hello.o" -> "hello.cpp";

"Компиляция main.cpp"
"Компиляция factorial.cpp"
"Компиляция hello.cpp"
"Компоновка исполняемого файла"

Содержимое memory.json:
{
  "hello.o": "e0f717132a90c2b86fc54cdadf85cd23",
  "main.cpp": "fd7833700807dac1ea9f357df37b39f3",
  "factorial.cpp": "7d4f51c6a8061dc5224a0424bde06c14",
  "hello.cpp": "4d1b492da8ddeff3755d9ad44b6c5f3b",
  "main.o": "028a389da0c91e444f1aeb004a12eecb",
  "factorial.o": "d761f9cfe52f2c4c78375414cb9e3f58"
}
```

2. Повторный вызов без ключа.
```
Input:
maker.py makefile

Output:
"Компоновка исполняемого файла"

Содержимое memory.json:
{
  "hello.o": "e0f717132a90c2b86fc54cdadf85cd23",
  "main.cpp": "fd7833700807dac1ea9f357df37b39f3",
  "factorial.cpp": "7d4f51c6a8061dc5224a0424bde06c14",
  "hello.cpp": "4d1b492da8ddeff3755d9ad44b6c5f3b",
  "main.o": "028a389da0c91e444f1aeb004a12eecb",
  "factorial.o": "d761f9cfe52f2c4c78375414cb9e3f58"
}
```

3. Повторный вызов после изменения файла `hello.cpp`.
```
Input:
maker.py makefile

Output:
"Компиляция hello.cpp"
"Компоновка исполняемого файла"

Содержимое memory.json:
{
  "hello.o": "e0f717132a90c2b86fc54cdadf85cd23",
  "main.cpp": "fd7833700807dac1ea9f357df37b39f3",
  "factorial.cpp": "7d4f51c6a8061dc5224a0424bde06c14",
  "hello.cpp": "e84d9058224c1f362554b5fd15c2b64b",
  "main.o": "028a389da0c91e444f1aeb004a12eecb",
  "factorial.o": "d761f9cfe52f2c4c78375414cb9e3f58"
}
```

Как видно при втором запуске изменилось хэш-значение только файла `hello.cpp`, хотя после отработки `makefile` изменится и файл `hello.o`.
